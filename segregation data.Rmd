This document shows the code for the cleaning and joining of the demographic "census" data, and creation of its dataset. 

## Load necessary libraries
```{r}
install.packages(c("readxl", "dplyr", "tidyr", "stats", "readr", "zoo", 
                   "ggplot2", "sf", "tmap", "sp", "spdep", "MASS", 
                    "tidyverse", "stringr", "ineq", "FactoMineR", 
                    "factoextra", "reshape2"))

# Load libraries
library(readxl)        
library(dplyr)        
library(tidyr)         
library(stats)         
library(readr)         
library(zoo)           
library(ggplot2) 
library(sp)            
library(MASS)         
library(tidyverse)    
library(stringr)       
library(ineq)          
library(factoextra)  
library(reshape2)      
```

## Load census data
```{r}
setwd("/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data")

# Demographic data
census_2001 <- read_csv("/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data/census 2001.csv")
census_2011 <- read_csv("/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data/census 2011 vf.csv")
census_2021 <- read_csv("/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data/census 2021.csv")

install.packages("sf", type = "binary")
library(sf)

# Define file paths for the shapefiles
msoa_path <- "/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data/MSOA_2011_London_gen_MHW.shp"
lsoa_path <- "/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data/LSOA_2011_London_gen_MHW.shp"
borough_path <- "/Users/anamariasteinercorrea/Desktop/v3 longitudinal diaspora study/Data/London_Borough_Excluding_MHW.shp"

# Read the shapefiles using st_read
msoa <- st_read(msoa_path, quiet = FALSE)
lsoa <- st_read(lsoa_path, quiet = FALSE)
borough <- st_read(borough_path, quiet = FALSE)
```

## Clean and join all data

### Spatial data
```{r}
# Eliminate columns
msoa <- dplyr::select(msoa, -USUALRES, -HHOLDRES, -COMESTRES, -POPDEN, -HHOLDS, -AVHHOLDSZ, -LAD11NM, -RGN11NM, -LAD11CD, -RGN11CD)

# Eliminate columns
lsoa <- dplyr::select(lsoa, -MSOA11CD, -MSOA11NM, -LAD11CD, -LAD11NM, -RGN11CD, -RGN11NM, -USUALRES, -HHOLDRES, -COMESTRES, -POPDEN, -HHOLDS, -AVHHOLDSZ)

# Eliminate columns
borough <- dplyr::select(borough, -HECTARES, -NONLD_AREA, -ONS_INNER, -SUB_2009, -SUB_2006)
```

### Demographic data

##### Census 2001
```{r}
# Load necessary packages
library(dplyr)

# Clean columns
names(census_2001)[names(census_2001) == "geography"] <- "MSOA11NM"
names(census_2001)[names(census_2001) == "geography code"] <- "MSOA11CD"
clean_2001 <- na.omit(census_2001)  
clean_2001$year <- 2001  

# Exclude unwanted columns
column_indices <- c(1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 43, 44, 45, 46, 48, 49, 50, 51, 52, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 73, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85)
cleaner_2001 <- clean_2001[, column_indices]

# Clean the nationality names and convert to numeric codes
cleaner_2001 <- cleaner_2001 %>%
  rename_with(~ gsub("Country of Birth: ", "", .x))

# Identify nationality columns 
non_nationality_columns <- c("MSOA11CD", "MSOA11NM", "date", "All categories: Country of birth; measures: Value")
nationality_columns <- setdiff(names(cleaner_2001), non_nationality_columns)

# Ensure all nationality columns are numeric
cleaner_2001[nationality_columns] <- lapply(cleaner_2001[nationality_columns], as.numeric)

# Add majority nationality value column
cleaner_2001 <- cleaner_2001 %>%
  rowwise() %>%
  mutate(
    Majority_Nationality_Value = max(c_across(all_of(nationality_columns)))
  ) %>%
  ungroup()

# Select only the total population and specified nationalities
specific_nationalities <- c("Romania; measures: Value", "Poland; measures: Value", 
                            "Jamaica; measures: Value", "Other Caribbean and West Indies; measures: Value", 
                            "Somalia; measures: Value", "Kenya; measures: Value", 
                            "South Africa; measures: Value", "Zimbabwe; measures: Value", 
                            "Other  South and Eastern Africa; measures: Value", "Bangladesh; measures: Value", 
                            "South America; measures: Value")

# Column for total population
total_population_column <- "All categories: Country of birth; measures: Value"

# Eliminate columns
final_2001 <- cleaner_2001 %>%
  dplyr::select(MSOA11NM, MSOA11CD, date, Majority_Nationality_Value, total_population_column, all_of(specific_nationalities))

# Clean the column names
final_2001 <- final_2001 %>%
  rename_with(~ gsub("; measures: Value", "", .x))

# Create new columns for aggregated nationalities
library(dplyr)

final_2001 <- final_2001 %>%
  mutate(
    Caribbean = `Jamaica` + `Other Caribbean and West Indies`,
    SEAfrica = `Somalia` + `Kenya` + `South Africa` + `Zimbabwe` + `Other  South and Eastern Africa`,
    SouthAmerica = `South America`
  ) %>%
  dplyr::select(-`Jamaica`, -`Other Caribbean and West Indies`, -`Somalia`, -`Kenya`, -`South Africa`, -`Zimbabwe`, 
                -`Other  South and Eastern Africa`, -`South America`)

final_2001 <- final_2001 %>%
  rename(
    Total_Population_2001 = `All categories: Country of birth`,
    Majority_2001 = `Majority_Nationality_Value`,
    Caribbean_2001 = Caribbean,
    SEAfrica_2001 = SEAfrica,
    Poland_2001 = Poland,
    Romania_2001 = Romania,
    Bangladesh_2001 = Bangladesh,
    SouthAmerica_2001 = SouthAmerica
  )
```

##### Census 2011
```{r}
# Cleaning
names(census_2011)[names(census_2011) == "geography"] <- "MSOA11NM"
names(census_2011)[names(census_2011) == "geography code"] <- "MSOA11CD"
clean_2011 <- na.omit(census_2011)  
clean_2011$year <- 2011  

# Eliminate columns
column_indices <- c(1, 2, 3, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 22, 23, 24, 25, 26, 27, 29, 30, 31, 32, 34, 35, 37, 39, 40, 41, 43, 44, 45, 46, 47, 48, 51, 52, 54, 55, 56, 58, 59, 60, 61, 62, 64, 65, 69, 70, 71, 72, 74, 75, 77, 79, 80, 81, 82)
cleaner_2011 <- clean_2011[, column_indices]

# Rename columns
specific_columns_corrected <- c(
  "Country of Birth: All categories: Country of birth; measures: Value",
  "Country of Birth: Europe: United Kingdom: England; measures: Value",
  "Country of Birth: Europe: Other Europe: EU countries: Accession countries April 2001 to March 2011: Romania; measures: Value",
  "Country of Birth: Europe: Other Europe: EU countries: Accession countries April 2001 to March 2011: Poland; measures: Value",
"Country of Birth: Africa: South and Eastern Africa: Kenya; measures: Value",                                                  "Country of Birth: Africa: South and Eastern Africa: Somalia; measures: Value",
"Country of Birth: Africa: South and Eastern Africa: South Africa; measures: Value",                                           "Country of Birth: Africa: South and Eastern Africa: Zimbabwe; measures: Value",                                               "Country of Birth: Africa: South and Eastern Africa: Other South and Eastern Africa; measures: Value", 
  "Country of Birth: Middle East and Asia: Southern Asia: Bangladesh; measures: Value",
  "Country of Birth: The Americas and the Caribbean: South America; measures: Value",
"Country of Birth: The Americas and the Caribbean: The Caribbean: Jamaica; measures: Value",                                                        "Country of Birth: The Americas and the Caribbean: The Caribbean: Other Caribbean; measures: Value" 
)

specific_nationalities <- c("total population", "Majority", "Romania", "Poland", "Kenya", "Somalia", "South Africa", "Zimbabwe", "Other South and Eastern Africa", "Bangladesh", "South America", "Jamaica", "Other Caribbean")

# Create final dataset
final_2011 <- cleaner_2011 %>%
  dplyr::select(MSOA11CD, MSOA11NM, date, all_of(specific_columns_corrected)) %>%
  dplyr::rename_with(~ specific_nationalities, .cols = all_of(specific_columns_corrected))

final_2011 <- final_2011 %>%
  dplyr::mutate(
    Caribbean = `Jamaica` + `Other Caribbean`,
    SEAfrica = `Somalia` + `Kenya` + `South Africa` + `Zimbabwe` + `Other South and Eastern Africa`
  ) %>%
  dplyr::select(-`Jamaica`, -`Other Caribbean`, -`Somalia`, -`Kenya`, -`South Africa`, -`Zimbabwe`, -`Other South and Eastern Africa`)

final_2011 <- final_2011 %>%
  rename(
    Total_Population_2011 = `total population`,
    Majority_2011 = `Majority`,
    Caribbean_2011 = Caribbean,
    SEAfrica_2011 = SEAfrica,
    Poland_2011 = Poland,
    Romania_2011 = Romania,
    Bangladesh_2011 = Bangladesh,
    SouthAmerica_2011 = `South America`
  )
```

##### Census 2021

```{r}
# Initial cleaning
names(census_2021)[names(census_2021) == "Middle layer Super Output Areas"] <- "MSOA11NM"
names(census_2021)[names(census_2021) == "Middle layer Super Output Areas Code"] <- "MSOA11CD"
clean_2021 <- na.omit(census_2021)

# Pivot wider
pivoted_2021 <- clean_2021 %>%
  pivot_wider(
    id_cols = c(MSOA11CD, MSOA11NM),
    names_from = `Country of birth (60 categories)`,
    values_from = Observation,
    values_fill = list(Observation = 0)
  )

clean_pivoted_2021 <- na.omit(pivoted_2021)
clean_pivoted_2021$date <- 2021
head(clean_pivoted_2021)

# Calculate total population from all nationality columns
total_columns <- grep("Europe|Africa|Middle East and Asia|The Americas and the Caribbean", names(clean_pivoted_2021), value = TRUE)
clean_pivoted_2021$Total_Population <- rowSums(clean_pivoted_2021[, total_columns], na.rm = TRUE)

# Define specific nationalities and their columns 
specific_columns <- c(
  "Europe: United Kingdom: England",
  "Europe: United Kingdom: Northern Ireland",
  "Europe: United Kingdom: Scotland",
  "Europe: United Kingdom: Wales",
  "Europe: Other Europe: EU countries: Countries that joined the EU between April 2001 and March 2011: Romania",
  "Europe: Other Europe: EU countries: Countries that joined the EU between April 2001 and March 2011: Poland",
  "Africa: South and Eastern Africa: Somalia",
  "Africa: South and Eastern Africa: Kenya",
  "Africa: South and Eastern Africa: South Africa",
  "Africa: South and Eastern Africa: Zimbabwe",
  "Africa: South and Eastern Africa: Other South and Eastern Africa",
  "Middle East and Asia: Southern Asia: Bangladesh",
  "The Americas and the Caribbean: South America: All South American countries",
  "The Americas and the Caribbean: The Caribbean: Jamaica",
  "The Americas and the Caribbean: The Caribbean: Other Caribbean"
)

# Prepare the final dataset
final_2021 <- clean_pivoted_2021 %>%
  dplyr::select(MSOA11CD, MSOA11NM, date, Total_Population, all_of(specific_columns)) %>%
  dplyr::rename(
    England_2021 = `Europe: United Kingdom: England`,
    Irland_2021 = `Europe: United Kingdom: Northern Ireland`,
    Scotland_2021 = `Europe: United Kingdom: Scotland`,
    Wales_2021 = `Europe: United Kingdom: Wales`,
    Romania_2021 = `Europe: Other Europe: EU countries: Countries that joined the EU between April 2001 and March 2011: Romania`,
    Poland_2021 = `Europe: Other Europe: EU countries: Countries that joined the EU between April 2001 and March 2011: Poland`,
    Somalia_2021 = `Africa: South and Eastern Africa: Somalia`,
    SEAfrica_2021 = `Africa: South and Eastern Africa: Other South and Eastern Africa`,
    Bangladesh_2021 = `Middle East and Asia: Southern Asia: Bangladesh`,
    SouthAmerica_2021 = `The Americas and the Caribbean: South America: All South American countries`,
    Kenya_2021 = `Africa: South and Eastern Africa: Kenya`,
    Zimbabwe_2021 = `Africa: South and Eastern Africa: Zimbabwe`,
    SAfrica_2021 = `Africa: South and Eastern Africa: South Africa`,
    Jamaica_2021 = `The Americas and the Caribbean: The Caribbean: Jamaica`,
    Caribbean_2021 = `The Americas and the Caribbean: The Caribbean: Other Caribbean`
  )

final_2021 <- final_2021 %>%
  dplyr::mutate(
    Caribbean_2021 = `Jamaica_2021` + `Caribbean_2021`,
    SEAfrica_2021 = `Somalia_2021` + `Kenya_2021` + `SAfrica_2021` + `Zimbabwe_2021` + `SEAfrica_2021`,
    Majority_2021 = `England_2021` + `Irland_2021` + `Scotland_2021` + `Wales_2021`
  ) %>%
  dplyr::select(-`Jamaica_2021`, -`Somalia_2021`, -`Kenya_2021`, -`SAfrica_2021`, -`Zimbabwe_2021`)

final_2021 <- final_2021 %>%
  dplyr::select(-England_2021, -Irland_2021, -Scotland_2021, -Wales_2021)
```

#### Create a complete census dataset
```{r}
# Merge the datasets by MSOA codes and names
combined_census <- final_2001 %>%
  full_join(final_2011, by = c("MSOA11CD", "MSOA11NM")) %>%
  full_join(final_2021, by = c("MSOA11CD", "MSOA11NM"))

# Clean NA values
final_census <- na.omit(combined_census)

# Eliminate columns
final_census <- dplyr::select(final_census, -date, -date.x, -date.y)

final_census <- final_census %>%
  rename(Total_Population_2021 = Total_Population)
```

#### Interpolate demogrpahic data set for non-census years
```{r}

colnames(final_census)
names(final_census)[17] <- "Total_Population_2021"
colnames(final_census)
names(final_census)[17] <- "Caribbean_2011"
names(final_census)[19] <- "Total_Population_2021"

# Transform the data into a long format with separate Nationality and Year columns
data_long <- final_census %>%
  pivot_longer(
    cols = -c(MSOA11CD, MSOA11NM), 
    names_to = c("Nationality", "Year"), 
    names_pattern = "(.*)_(\\d{4})",
    values_to = "Population"
  )

# Convert Year to numeric
data_long$Year <- as.numeric(data_long$Year)

# Interpolate for odd years between 2001 and 2021
library(zoo)
data_long_interpolated <- data_long %>%
  group_by(MSOA11CD, Nationality) %>%
  complete(Year = seq(2001, 2021, by = 1)) %>%
  arrange(Year) %>%
  mutate(Population = na.approx(Population, rule = 2))

# Filter to keep only odd years
data_long_odd_years <- data_long_interpolated %>%
  filter(Year %% 2 == 1)

```
#### Join geometry to final dataset

```{r}
library(tidyr)

# Fill down the MSOA11NM column
data_long_odd_years <- data_long_odd_years %>%
  group_by(MSOA11CD) %>%
  fill(MSOA11NM, .direction = "downup") %>%
  ungroup()

# Join to msoa shp
msoa_census <- left_join(msoa, data_long_odd_years, by = c("MSOA11NM", "MSOA11CD"))
```

#### Interpolate demogrpahic data set for non-census years
```{r}
# Calculate proportions of each nationality
census_final <- msoa_census %>%
  group_by(MSOA11CD, Year) %>%
  mutate(
    Total_Pop = Population[Nationality == "Total_Population"],
    Proportion = ifelse(Nationality == "Total_Population", 1, Population / Total_Pop)
  ) %>%
  ungroup()
```

## Calculation of 3 Segregation analysis

```{r}
# Replace zero proportions with a small value
census_final$Proportion <- ifelse(census_final$Proportion == 0, 0.00001, census_final$Proportion)
```

### Dissimilarity index

#### Dissimiliarity index

```{r}
library(dplyr)
library(sf)

# Specify the nationalities to compare against the majority
nationalities <- c("Romania", "Poland", "Caribbean", "SouthAmerica", "SEAfrica", "Bangladesh")

# Get unique years
years <- unique(census_final$Year)

# Initialize a dataframe to store results
dissimilarity_results <- data.frame(
  MSOA11CD = character(), 
  Year = integer(), 
  Nationality = character(), 
  Dissimilarity_Index = numeric(), 
  stringsAsFactors = FALSE
)

for (year in years) {
  for (nat in nationalities) {
    # Filter data for the majority population in the current year
    data_majority <- census_final %>%
      filter(Nationality == "Majority" & Year == year) %>%
      st_drop_geometry() %>%
      dplyr::select(MSOA11CD, Year, Population) %>%
      rename(Population_majority = Population)

    # Filter data for the specific nationality in the current year
    data_nationality <- census_final %>%
      filter(Nationality == nat & Year == year) %>%
      st_drop_geometry() %>%
      dplyr::select(MSOA11CD, Year, Population) %>%
      rename(Population_nat = Population)

    # Merge the majority and nationality data on MSOA and Year
    merged_data <- merge(data_majority, data_nationality, by = c("MSOA11CD", "Year"))

    if (nrow(merged_data) > 0) {
      # Calculate the total population for majority and the target nationality
      total_majority <- sum(merged_data$Population_majority)
      total_nat <- sum(merged_data$Population_nat)

      # Calculate the Dissimilarity Index for each MSOA using count data and scale by 1000
      merged_data <- merged_data %>%
        mutate(Dissimilarity = 0.5 * abs((Population_majority / total_majority) - (Population_nat / total_nat)) * 100)

      # Store the results
      dissimilarity_results <- rbind(
        dissimilarity_results,
        data.frame(
          MSOA11CD = merged_data$MSOA11CD,
          Year = merged_data$Year,
          Nationality = nat,
          Dissimilarity_Index = merged_data$Dissimilarity
        )
      )
    }
  }
}

# Print the dissimilarity results
print(dissimilarity_results)

# Join the Dissimilarity Index back to the original dataset if needed
census_final_updated <- census_final %>%
  left_join(dissimilarity_results, by = c("MSOA11CD", "Year", "Nationality"))

# Print or save the updated dataset
print(census_final_updated)
```

#### Lagged diss (-1)

```{r}
# Calculate the lagged Dissimilarity Index and handle 2001 case
census_final_updated <- census_final_updated %>%
  arrange(MSOA11CD, Nationality, Year) %>% # Ensure data is sorted by MSOA, Nationality, and Year
  group_by(MSOA11CD, Nationality) %>% # Group by MSOA and Nationality
  mutate(
    Lagged_Dissimilarity = lag(Dissimilarity_Index), # Calculate the lagged value
    Lagged_Dissimilarity = ifelse(is.na(Lagged_Dissimilarity) & Year == 2001, Dissimilarity_Index, Lagged_Dissimilarity) # Repeat 2001 value
  ) %>%
  ungroup() # Remove grouping

# Print the updated dataset
print(census_final_updated)
```

### Theil's H index
```{r}

library(data.table)
final_census_dt <- as.data.table(census_final_updated)

# Function to calculate Theil's H for a given dataframe
calculate_theils_h <- function(df) {
  df <- df %>%
    mutate(Theils_H = ifelse(Proportion > 0, Proportion * log(1 / Proportion), 0))  
  return(sum(df$Theils_H, na.rm = TRUE))  
}

theils_h_results <- final_census_dt[Nationality != "Total_Population" & Nationality != "Majority",
                                    .(H = sum(ifelse(Proportion > 0, Proportion * log(1 / Proportion), 0), na.rm = TRUE)),
                                    by = .(MSOA11CD, Year)]

# Merge Theil's H results back into the final_census dataframe
final_final_census <- census_final_updated %>%
  left_join(theils_h_results, by = c("MSOA11CD", "Year"))

# Check the result
print(final_final_census)

```

### Isolation index
```{r}
# Convert final_final_census to data.table
final_final_census_dt <- as.data.table(final_final_census)

# Function to calculate Isolation Index for a given data.table
calculate_isolation_index <- function(df) {
  df[, .(Isolation_Index = sum(Proportion^2, na.rm = TRUE))]
}

# Calculate Isolation Index for each MSOA and Year using data.table
isolation_results_dt <- final_final_census_dt[
  Nationality != "Total_Population" & Nationality != "Majority", 
  calculate_isolation_index(.SD), 
  by = .(MSOA11CD, Year)
]

# Merge Isolation Index results back into the original data.table
finalest_census_dt <- merge(final_final_census_dt, isolation_results_dt, by = c("MSOA11CD", "Year"), all.x = TRUE)

# Check the result
print(finalest_census_dt)
```

```{r}
# Final cleaning

# Filter out rows where Nationality is "Total_Population" or "Majority"
finalest_census_dt <- finalest_census_dt[!(Nationality %in% c("Total_Population", "Majority"))]

# Remove the columns "Total_Pop" and "Population"
finalest_census_dt <- finalest_census_dt[, !c("Total_Pop", "Population"), with = FALSE]
```

## Download CSV
```{r}
# Remove the geometry column from the data frame
census_no_geo <- st_drop_geometry(finalest_census_dt)

# Download as a csv 
write.csv(census_no_geo, "census_data.csv", row.names = FALSE)
```

```{r}
# Remove rows with any NA values
census_data_clean <- na.omit(finalest_census_dt)
```

```{r}
# Replace Dissimilarity_Index > 1 with 0.8 in base R
finalest_census_dt$Dissimilarity_Index <- ifelse(
  finalest_census_dt$Dissimilarity_Index > 1,
  0.8,
  finalest_census_dt$Dissimilarity_Index
)

# Filter rows where Dissimilarity_Index is 0.8 and summarize by Nationality
high_dissimilarity_msoas <- finalest_census_dt[finalest_census_dt$Dissimilarity_Index == 0.8, ] %>%
  group_by(Nationality) %>%
  summarise(
    MSOA_Count = n(),
    MSOAs = paste(unique(MSOA11CD), collapse = ", ")
  ) %>%
  arrange(desc(MSOA_Count))

# View the result
print(high_dissimilarity_msoas)
```

```{r}
# Loop through each nationality and calculate statistics
for (nationality in unique(finalest_census_dt$Nationality)) {
  # Filter data for the current nationality
  nat_data <- finalest_census_dt %>%
    filter(Nationality == nationality)
  
  # Calculate statistics
  min_value <- min(nat_data$Dissimilarity_Index, na.rm = TRUE)
  max_value <- max(nat_data$Dissimilarity_Index, na.rm = TRUE)
  median_value <- median(nat_data$Dissimilarity_Index, na.rm = TRUE)
  mean_value <- mean(nat_data$Dissimilarity_Index, na.rm = TRUE)
  
  # Print results for the current nationality
  cat("Nationality:", nationality, "\n")
  cat("Min:", min_value, "\n")
  cat("Max:", max_value, "\n")
  cat("Median:", median_value, "\n")
  cat("Mean:", mean_value, "\n\n")
}
```

### Visualice histograms and boxplots of distributions

```{r}
# Directory for histogram and boxplot outputs
dir.create("distribution_plots", showWarnings = FALSE)

# Histograms for all indices
for (var in c("Proportion", "Dissimilarity_Index", "Isolation_Index", "H")) {
  hist_plot <- ggplot(finalest_census_dt, aes_string(x = var)) +
    geom_histogram(bins = 30, fill = "blue", color = "black", alpha = 0.7) +
    facet_wrap(~ Nationality, scales = "free") +
    labs(title = paste("Histogram of", var, "by Nationality"),
         x = var, y = "Count") +
    theme_minimal()
  
  # Save histogram
  ggsave(filename = paste0("distribution_plots/Histogram_", var, ".png"),
         plot = hist_plot, width = 10, height = 6)
}

# Boxplots for all indices
for (var in c("Proportion", "Dissimilarity_Index", "Isolation_Index", "H")) {
  box_plot <- ggplot(finalest_census_dt, aes(x = Nationality, y = !!sym(var))) +
    geom_boxplot(fill = "lightblue", color = "black", alpha = 0.7) +
    labs(title = paste("Boxplot of", var, "by Nationality"),
         x = "Nationality", y = var) +
    theme_minimal()
  
  # Save boxplot
  ggsave(filename = paste0("distribution_plots/Boxplot_", var, ".png"),
         plot = box_plot, width = 10, height = 6)
}
```

### Visualice temporal line graphs of all indices
```{r}
library(ggplot2)
library(dplyr)

# Ensure Year is numeric
finalest_census_dt$Year <- as.numeric(finalest_census_dt$Year)

# Aggregate data by Year and Nationality
aggregated_data <- finalest_census_dt %>%
  group_by(Year, Nationality) %>%
  summarize(
    Proportion = mean(Proportion, na.rm = TRUE),
    Dissimilarity_Index = mean(Dissimilarity_Index, na.rm = TRUE),
    Lagged_Dissimilarity = mean(Lagged_Dissimilarity, na.rm = TRUE),
    H = mean(H, na.rm = TRUE),
    Isolation_Index = mean(Isolation_Index, na.rm = TRUE),
    .groups = "drop"
  )

# Create directory for nationality-wise plots
dir.create("line_graphs_nationality", showWarnings = FALSE)

# Loop through each nationality and create line plots
nationalities <- unique(aggregated_data$Nationality)

for (nationality in nationalities) {
  # Filter data for the current nationality
  nat_data <- aggregated_data %>%
    filter(Nationality == nationality)

  # Generate the line plot
  plot <- ggplot(nat_data) +
    geom_line(aes(x = Year, y = Proportion, color = "Proportion"), size = 1.2) +
    geom_line(aes(x = Year, y = Dissimilarity_Index, color = "Dissimilarity Index"), size = 1.2) +
    geom_line(aes(x = Year, y = H, color = "Theil's H"), size = 1.2) +
    geom_line(aes(x = Year, y = Isolation_Index, color = "Isolation Index"), size = 1.2) +
    labs(
      title = paste("Temporal Trends for", nationality),
      x = "Year", y = "Value", color = "Index"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "top"
    )

  # Save the plot
  ggsave(
    filename = paste0("line_graphs_nationality/Trends_", nationality, ".png"),
    plot = plot,
    width = 10,
    height = 6
  )
}
```

### Visualice and compare temporal line graph between all nationalities
```{r}
# Create line graph for Dissimilarity Index comparing all nationalities
dissimilarity_plot <- ggplot(aggregated_data, aes(x = Year, y = Dissimilarity_Index, color = Nationality, group = Nationality)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  scale_y_continuous(
    labels = function(x) x * 10, # Scale the y-axis labels by 10
    breaks = seq(0.01, 0.07, by = 0.01) # Adjust breaks based on data range
  ) +
  labs(
    title = "Dissimilarity Index Over Time (All Nationalities)",
    x = "Year",
    y = "Scaled Dissimilarity Index (0.1 - 0.7)", # Update label for clarity
    color = "Nationality"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Save the plot
dir.create("line_graphs_comparison", showWarnings = FALSE)
ggsave(filename = "line_graphs_comparison/Dissimilarity_Index_All_Nationalities.png",
       plot = dissimilarity_plot, width = 10, height = 6)
```

### Calculate spatial autocorrelation of diss index between nationalities

```{r}
library(sf)
library(dplyr)
library(ggplot2)
library(Matrix)
library(FNN)

# Ensure consistent CRS for geometries
finalest_census_dt <- finalest_census_dt %>%
  st_as_sf() %>% # Ensure it is an sf object
  st_transform(crs = 27700) # Example: British National Grid

# Create unique geometries with MSOA codes
unique_geometries <- finalest_census_dt %>%
  group_by(MSOA11CD) %>%
  slice(1) %>% # Retain the first row for each MSOA11CD
  ungroup() %>% # Remove grouping to avoid issues in downstream operations
  dplyr::select(MSOA11CD, geometry) %>% # Keep only MSOA11CD and geometry columns
  st_as_sf() # Ensure the result is an sf object

# Ensure CRS is consistent for unique_geometries
unique_geometries <- st_transform(unique_geometries, crs = 27700)

# Get unique nationalities
nationalities <- unique(finalest_census_dt$Nationality)

# Loop through each nationality
for (nationality in nationalities) {
  # Filter data for the current nationality
  nat_data <- finalest_census_dt %>%
    filter(Nationality == nationality) %>%
    dplyr::select(MSOA11CD, Year, Dissimilarity_Index, geometry) %>%
    distinct()

  # Use st_join for spatial join (ensuring proper handling of sf objects)
  nat_data <- st_join(unique_geometries, nat_data, left = TRUE)

  # Ensure nat_data is still an sf object
  nat_data <- st_as_sf(nat_data)

  # Prepare dissimilarity index values and handle missing data
  x <- nat_data$Dissimilarity_Index
  x[is.na(x)] <- mean(x, na.rm = TRUE)  # Replace NA with mean value
  x_mean <- mean(x, na.rm = TRUE)

  # Recompute centroids and weights matrix for this subset
  coords <- st_coordinates(st_centroid(st_geometry(nat_data)))
  knn <- get.knn(coords, k = 10)

  # Create a sparse weights matrix for this subset
  weights <- sparseMatrix(
    i = rep(1:nrow(knn$nn.index), each = 10),
    j = as.vector(knn$nn.index),
    x = 1,
    dims = c(nrow(coords), nrow(coords))
  )

  # Row-standardize the weights matrix
  row_sums <- rowSums(weights)
  row_standardized_weights <- weights / row_sums

  # Compute Local Moran's I manually
  local_moran <- numeric(length(x))
  for (i in seq_along(x)) {
    neighbors <- which(row_standardized_weights[i, ] > 0)
    lagged_value <- sum(row_standardized_weights[i, neighbors] * x[neighbors], na.rm = TRUE)
    local_moran[i] <- (x[i] - x_mean) * (lagged_value - x_mean)
  }

  # Normalize Local Moran's I
  local_moran <- local_moran / var(x, na.rm = TRUE)

  # Add Moran's I results to nat_data
  nat_data <- nat_data %>%
    mutate(Local_I = local_moran,
           Quadrant = case_when(
             (Dissimilarity_Index > x_mean & Local_I > 0) ~ "High-High",
             (Dissimilarity_Index < x_mean & Local_I > 0) ~ "Low-Low",
             (Dissimilarity_Index > x_mean & Local_I < 0) ~ "High-Low",
             (Dissimilarity_Index < x_mean & Local_I < 0) ~ "Low-High",
             TRUE ~ "Non-significant"
           ))

  # Create LISA Map
  lisa_map <- ggplot(data = nat_data) +
    geom_sf(aes(fill = Quadrant), color = NA) +
    scale_fill_manual(values = c("High-High" = "red", "Low-Low" = "blue",
                                 "High-Low" = "orange", "Low-High" = "green",
                                 "Non-significant" = "grey")) +
    labs(title = paste("LISA Map for", nationality),
         fill = "Quadrant") +
    theme_minimal()

  # Save LISA Map
  if (!dir.exists("moran_outputs")) dir.create("moran_outputs")
  ggsave(filename = paste0("moran_outputs/LISA_Map_", nationality, ".png"),
         plot = lisa_map, width = 10, height = 8)

  # Print progress
  print(paste("Completed Moran's I and LISA Map for:", nationality))
}
```

```{r}
# Moran's I	Meaning
> 0	Positive spatial autocorrelation (clustering)
< 0	Negative spatial autocorrelation (dispersion)
≈ 0	No spatial autocorrelation (random)
P-Value	Interpretation
< 0.05	Significant spatial autocorrelation
> 0.05	No significant spatial autocorrelation
```

```{r}
Mixed Red/Orange Areas

Likely represent historically segregated regions.
These regions may be where immigrant communities settled initially, creating dense cultural and ethnic clusters.
These areas may require policies aimed at fostering integration, such as:
Affordable mixed-income housing.
Educational investments to promote mobility.
Mixed Blue/Green Areas

Likely represent integrated suburban or redevelopment zones.
These areas might reflect a balance of diverse groups, driven by:
Suburban housing policies.
Urban regeneration and investment in infrastructure.
These regions might provide insights into successful policies for replication in other areas.
```

### Visualice maps of diss index between nationalities and through time
```{r}
library(ggplot2)
library(sf)

# Create directory for spatial maps
dir.create("spatial_maps", showWarnings = FALSE)

# Loop through each nationality to create maps
nationalities <- unique(finalest_census_dt$Nationality)

for (nationality in nationalities) {
  # Filter data for the current nationality
  nat_data <- finalest_census_dt %>%
    filter(Nationality == nationality)
  
  # Plot map for the current nationality
  diss_map <- ggplot(nat_data) +
    geom_sf(aes(fill = Dissimilarity_Index, geometry = geometry), color = NA) +
    scale_fill_viridis_c(option = "C", name = "Dissimilarity Index") +
    labs(
      title = paste("Dissimilarity Index Across London -", nationality),
      caption = "Source: Census Data"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "right"
    )
  
  # Save the plot
  ggsave(
    filename = paste0("spatial_maps/Dissimilarity_Index_", nationality, ".png"),
    plot = diss_map,
    width = 12,
    height = 8
  )
}
```

### Identify MSOAs with Most Changes in Dissimilarity Index

```{r}
# Calculate change in Diss_Index over time
change_stats <- finalest_census_dt %>%
  filter(!is.na(Dissimilarity_Index), !is.na(Nationality)) %>%  # Remove rows with NA Diss_Index or Nationality
  group_by(MSOA11CD, Nationality) %>%
  summarize(
    Diss_Index_Change = max(Dissimilarity_Index) - min(Dissimilarity_Index),  # No need for na.rm as NA rows are excluded
    .groups = "drop"
  )

# Top MSOAs where segregation DECREASED
top_msoas_decreased <- change_stats %>%
  filter(Diss_Index_Change < 0) %>%
  arrange(Diss_Index_Change) %>%
  group_by(Nationality) %>%
  slice_head(n = 5)

# View top MSOAs with decreased segregation
print(top_msoas_decreased)

# Top MSOAs where segregation INCREASED
top_msoas_increased <- change_stats %>%
  filter(Diss_Index_Change > 0) %>%
  arrange(desc(Diss_Index_Change)) %>%
  group_by(Nationality) %>%
  slice_head(n = 5)

# View top MSOAs with increased segregation
print(top_msoas_increased)
```




